"""
Vulnerability Crew Definition
Defines the AI agents and tasks for naval electronic warfare attack response

CHANGES FROM ORIGINAL:
- Disabled delegation in all agents (allow_delegation=False)
- Added max_iter safety limits to prevent infinite loops
- Simplified agent configuration for single-pass execution
"""
import os
from pathlib import Path
from typing import List
import yaml
from crewai import Agent, Crew, Process, Task
from crewai.project import CrewBase, agent, crew, task

# Import tools
from src.tools.multimodal_tools import (
    InputTypeDeterminerTool,
    EWSignalProcessor,
    ESMSensorSimulator,
    ELINTSensorSimulator,
    GNSSReceiverSimulator,
    CommunicationReceiverSimulator
)
from src.tools.network_anomaly_detector import NetworkAnomalyDetector
from src.tools.jamming_classifier import JammingClassifier
from src.tools.countermeasure_simulator import CountermeasureSimulator
from src.tools.actuator_tools import (
    ECMActuator,
    FrequencyHopActuator,
    PowerIncreaseActuator,
    UAVActuator,
    EvasiveManeuverActuator,
    EMCONActuator,
    AlternativeChannelActuator
)

# Import logging
from src.utils.logger import get_logger

logger = get_logger(__name__)


# Get absolute path to config directory
SCRIPT_DIR = Path(__file__).parent  # /path/to/src/
PROJECT_ROOT = SCRIPT_DIR.parent    # /path/to/project/
CONFIG_DIR = PROJECT_ROOT / 'config'

logger.debug(f"Config directory resolved to: {CONFIG_DIR}")
logger.debug(f"Agents config: {CONFIG_DIR / 'agents.yaml'}")
logger.debug(f"Tasks config: {CONFIG_DIR / 'tasks.yaml'}")


@CrewBase
class VulnerabilityCrew:
    """Naval Vulnerability Response Crew - Electronic Warfare Attack Response"""
    
    # Paths relative to src/ directory (where crew.py is located)
    # CrewAI necesita rutas absolutas para evitar que las duplique internamente
    agents_config = str((Path(__file__).resolve().parent.parent / "config" / "agents.yaml").resolve())
    tasks_config = str((Path(__file__).resolve().parent.parent / "config" / "tasks.yaml").resolve())

    
    def __init__(self):
        logger.info("Initializing Vulnerability Crew")

        logger.debug(f"Loading agents config from: {self.agents_config}")
        logger.debug(f"Loading tasks config from: {self.tasks_config}")

        # Load YAML configs safely with debugging
        try:
            with open(self.agents_config, "r") as f:
                self.agents_config = yaml.safe_load(f)
            logger.debug(f"Agents config type: {type(self.agents_config)}")
            if not isinstance(self.agents_config, dict):
                raise ValueError(f"agents.yaml loaded as {type(self.agents_config)} instead of dict")

            with open(self.tasks_config, "r") as f:
                self.tasks_config = yaml.safe_load(f)
            logger.debug(f"Tasks config type: {type(self.tasks_config)}")
            if not isinstance(self.tasks_config, dict):
                raise ValueError(f"tasks.yaml loaded as {type(self.tasks_config)} instead of dict")

            logger.info(f"✓ Agents config loaded with {len(self.agents_config)} entries: {list(self.agents_config.keys())}")
            logger.info(f"✓ Tasks config loaded with {len(self.tasks_config)} entries: {list(self.tasks_config.keys())}")

        except Exception as e:
            logger.error(f"Failed to load YAML configs: {e}", exc_info=True)
            raise RuntimeError(f"Error loading YAML configs: {e}")
        
        # Initialize tools
        self.detection_tools = self._setup_detection_tools()
        self.classification_tools = self._setup_classification_tools()
        self.planning_tools = self._setup_planning_tools()
        self.actuator_tools = self._setup_actuator_tools()
        
        logger.info(f"Tools initialized: {len(self.detection_tools) + len(self.classification_tools) + len(self.planning_tools) + len(self.actuator_tools)} total")

    
    def _setup_detection_tools(self) -> List:
        """Initialize detection tools for cybersecurity agent"""
        logger.debug("Setting up detection tools")
        return [
            NetworkAnomalyDetector()
        ]
    
    def _setup_classification_tools(self) -> List:
        """Initialize classification tools for EW agent"""
        logger.debug("Setting up classification tools")
        return [
            InputTypeDeterminerTool(),
            EWSignalProcessor(),
            ESMSensorSimulator(),
            ELINTSensorSimulator(),
            GNSSReceiverSimulator(),
            CommunicationReceiverSimulator(),
            JammingClassifier()
        ]
    
    def _setup_planning_tools(self) -> List:
        """Initialize planning tools for tactical and evaluator agents"""
        logger.debug("Setting up planning tools")
        return [
            CountermeasureSimulator()
        ]
    
    def _setup_actuator_tools(self) -> List:
        """Initialize actuator tools for execution agent"""
        logger.debug("Setting up actuator tools")
        return [
            ECMActuator(),
            FrequencyHopActuator(),
            PowerIncreaseActuator(),
            UAVActuator(),
            EvasiveManeuverActuator(),
            EMCONActuator(),
            AlternativeChannelActuator()
        ]
    
    @agent
    def cybersecurity_agent(self) -> Agent:
        """
        Agent to detect network-level anomalies indicating electronic attack.
        Analyzes network traffic for signs of jamming-induced degradation.
        """
        logger.debug("Creating Cybersecurity Agent")
        
        return Agent(
            config=self.agents_config['cybersecurity_agent'],
            tools=self.detection_tools,
            verbose=True,
            allow_delegation=False,  # WARNING: Delegation disabled
            max_iter=3  # WARNING: Safety limit on tool calls
        )
    
    @agent
    def electronic_warfare_agent(self) -> Agent:
        """
        Agent to classify jamming sources and recommend countermeasures.
        Uses EW sensors and jamming database for classification.
        """
        logger.debug("Creating Electronic Warfare Agent")
        
        return Agent(
            config=self.agents_config['electronic_warfare_agent'],
            tools=self.classification_tools,
            verbose=True,
            allow_delegation=False,  # Delegation disabled (we were falling into infinite loops)
            max_iter=10  # Safety limit (needs more for sensor tools)
        )
    
    @agent
    def tactical_planning_agent(self) -> Agent:
        """
        Agent to develop tactical countermeasure plans.
        Proposes 3 distinct approaches for human selection.
        
        update: Delegation disabled. Agent generates all 3 plans in one pass.
        Plans are passed to evaluator via context, not agent communication.
        """
        logger.debug("Creating Tactical Planning Agent")
        
        return Agent(
            config=self.agents_config['tactical_planning_agent'],
            tools=self.planning_tools,
            verbose=True,
            allow_delegation=False,  # WARNING: No delegation to evaluator
            max_iter=5  # WARNING: Safety limit (shouldn't need tools, but just in case)
        )
    
    @agent
    def evaluator_agent(self) -> Agent:
        """
        Agent to evaluate and approve tactical plans.
        Uses simulation to validate plan viability.
        
        CHANGE: Delegation disabled. Agent reads plans from context and simulates
        each one exactly once (3 tool calls total).
        """
        logger.debug("Creating Evaluator Agent")
        
        return Agent(
            config=self.agents_config['evaluator_agent'],
            tools=self.planning_tools,
            verbose=True,
            allow_delegation=False,  # IMPORTANT: No delegation back to planner
            max_iter=5  # IMPORTANT: Safety limit (3 simulations + 2 buffer)
        )
    
    @agent
    def actuator_agent(self) -> Agent:
        """
        Agent to execute selected countermeasure plan.
        Deploys all countermeasures and reports results.
        """
        logger.debug("Creating Actuator Agent")
        
        return Agent(
            config=self.agents_config['actuator_agent'],
            tools=self.actuator_tools,
            verbose=True,
            allow_delegation=False,  # WARNING: Delegation disabled
            max_iter=15  # WARNING: Safety limit (max ~10 countermeasures expected)
        )
    
    @task
    def network_anomaly_detection_task(self) -> Task:
        """Task to detect network anomalies"""
        logger.debug("Creating network anomaly detection task")
        return Task(
            config=self.tasks_config['network_anomaly_detection_task']
        )
    
    @task
    def jamming_classification_task(self) -> Task:
        """Task to classify jamming sources"""
        logger.debug("Creating jamming classification task")
        return Task(
            config=self.tasks_config['jamming_classification_task']
        )
    
    @task
    def tactical_planning_task(self) -> Task:
        """Task to develop countermeasure plans"""
        logger.debug("Creating tactical planning task")
        return Task(
            config=self.tasks_config['tactical_planning_task']
        )
    
    @task
    def plan_evaluation_task(self) -> Task:
        """Task to evaluate and approve plans"""
        logger.debug("Creating plan evaluation task")
        return Task(
            config=self.tasks_config['plan_evaluation_task']
        )
    
    @task
    def countermeasure_execution_task(self) -> Task:
        """Task to execute selected countermeasure plan"""
        logger.debug("Creating countermeasure execution task")
        return Task(
            config=self.tasks_config['countermeasure_execution_task']
        )
    
    @crew
    def crew(self) -> Crew:
        """Creates the Vulnerability Response Crew"""
        try:
            logger.info("Assembling Vulnerability Crew")
            
            crew_instance = Crew(
                agents=self.agents,
                tasks=self.tasks,
                process=Process.sequential,  # Sequential execution
                verbose=True,
                full_output=True,
                output_folder='output',
                max_rpm=20  # Rate limiting to prevent runaway execution
            )
            
            logger.info("✓ Vulnerability Crew assembled successfully")
            logger.info(f"  Agents: {len(self.agents)}")
            logger.info(f"  Tasks: {len(self.tasks)}")
            logger.info("  Configuration: Delegation DISABLED, max_iter ENABLED")
            
            return crew_instance
            
        except Exception as e:
            logger.error(f"Failed to create crew: {e}", exc_info=True)
            raise RuntimeError(f"Cannot create crew: {e}")