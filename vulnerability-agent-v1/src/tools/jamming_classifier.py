"""
Jamming Classifier Tool
Classifies jamming sources by type and recommends appropriate countermeasures
Uses the jamming database to match attack patterns with known signatures
"""

import json
import os
from typing import Type, Optional, Dict, List
from pathlib import Path
from crewai.tools import BaseTool
from pydantic import BaseModel, Field

from src.utils.logger import get_logger

logger = get_logger(__name__)


# Get absolute path to jamming database
PROJECT_ROOT = Path(__file__).parent.parent.parent
JAMMING_DB_PATH = PROJECT_ROOT / 'config' / 'jamming_database.json'


class JammingClassifierInput(BaseModel):
    """Input schema for jamming classification"""
    attack_data: str = Field(
        ...,
        description="JSON string or file path containing attack scenario with jamming sources"
    )


class JammingClassifier(BaseTool):
    """Classifies jamming sources and recommends countermeasures"""
    
    name: str = "Jamming Classifier"
    description: str = (
        "Classifies detected jamming sources by type (barrage, spot, sweep, deceptive, etc.) "
        "and recommends appropriate countermeasures based on technical characteristics. "
        "Uses jamming database for classification. "
        "Input: attack_data (JSON string or file path)"
    )
    args_schema: Type[BaseModel] = JammingClassifierInput
    
    # Use private attribute to avoid Pydantic validation
    _jamming_db: Dict = {}
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._jamming_db = self._load_jamming_database()
    
    def _load_jamming_database(self) -> Dict:
        """Load jamming database from config"""
        try:
            logger.debug(f"Loading jamming database from: {JAMMING_DB_PATH}")
            
            if not JAMMING_DB_PATH.exists():
                logger.error(f"Jamming database not found at: {JAMMING_DB_PATH}")
                return {}
            
            with open(JAMMING_DB_PATH, 'r') as f:
                db = json.load(f)
            
            logger.info("Jamming database loaded successfully")
            return db
            
        except Exception as e:
            logger.error(f"Failed to load jamming database: {e}")
            return {}
    
    def _run(self, attack_data: str) -> str:
        try:
            logger.info("Classifying jamming sources")
            
            # Parse attack data
            data = self._parse_attack_data(attack_data)
            
            if not data:
                logger.error("Failed to parse attack data")
                return "ERROR: Could not parse attack data"
            
            # Extract jamming sources
            sources = data.get('sources', [])
            
            if not sources:
                logger.warning("No jamming sources to classify")
                return "NO SOURCES: No jamming sources detected in attack data"
            
            logger.info(f"Classifying {len(sources)} jamming sources")
            
            # Classify each source
            classified_sources = []
            for source in sources:
                classification = self._classify_source(source)
                classified_sources.append(classification)
            
            # Build report
            report = self._build_classification_report(classified_sources, data)
            logger.info("Jamming classification completed")
            
            return report
            
        except Exception as e:
            logger.error(f"Jamming classification error: {e}", exc_info=True)
            return f"ERROR in jamming classification: {str(e)}"
    
    def _parse_attack_data(self, attack_data: str) -> Optional[Dict]:
        """Parse attack data from file or JSON string"""
        try:
            if os.path.exists(attack_data):
                logger.debug(f"Reading attack data from file: {attack_data}")
                with open(attack_data, 'r') as f:
                    return json.load(f)
            
            logger.debug("Parsing attack data as JSON string")
            return json.loads(attack_data)
        
        except Exception as e:
            logger.error(f"Failed to parse attack data: {e}")
            return None
    
    def _classify_source(self, source: Dict) -> Dict:
        """Classify a single jamming source"""
        jamming_type = source.get('jamming_type', 'unknown').lower()
        source_id = source.get('source_id', 'UNKNOWN')
        
        logger.debug(f"Classifying source {source_id} as {jamming_type}")
        
        # Get classification data from database
        jamming_types = self._jamming_db.get('jamming_types', {})
        jamming_info = jamming_types.get(jamming_type, {})
        
        if not jamming_info:
            logger.warning(f"Unknown jamming type: {jamming_type}")
            jamming_info = {
                'name': 'Unknown Jamming Type',
                'description': 'Unrecognized jamming pattern',
                'threat_level': 'medium',
                'recommended_countermeasures': []
            }
        
        # Build classification result
        classification = {
            'source_id': source_id,
            'jamming_type': jamming_type,
            'name': jamming_info.get('name', 'Unknown'),
            'description': jamming_info.get('description', 'No description'),
            'threat_level': jamming_info.get('threat_level', 'unknown'),
            'frequency_mhz': source.get('frequency_mhz', 0),
            'power_dbm': source.get('power_dbm', 0),
            'location': source.get('location', {}),
            'affected_systems': source.get('affected_systems', []),
            'recommended_countermeasures': jamming_info.get('recommended_countermeasures', [])
        }
        
        return classification
    
    def _build_classification_report(
        self,
        classified_sources: List[Dict],
        data: Dict
    ) -> str:
        """Build jamming classification report"""
        
        timestamp = data.get('timestamp', 'Unknown')
        attack_type = data.get('attack_type', 'jamming')
        
        report_lines = [
            "=" * 70,
            "JAMMING SOURCE CLASSIFICATION REPORT",
            "=" * 70,
            f"Attack Type: {attack_type.upper()}",
            f"Detection Time: {timestamp}",
            f"Sources Classified: {len(classified_sources)}",
            ""
        ]
        
        # Overall threat assessment
        overall_threat = self._assess_overall_threat(classified_sources)
        report_lines.extend([
            "OVERALL THREAT ASSESSMENT:",
            "-" * 70,
            f"  Threat Level: {overall_threat['level'].upper()}",
            f"  Severity Score: {overall_threat['score']}/100",
            f"  Critical Sources: {overall_threat['critical_count']}",
            f"  High Threat Sources: {overall_threat['high_count']}",
            ""
        ])
        
        # Classify each source
        for idx, classification in enumerate(classified_sources, 1):
            report_lines.extend([
                f"SOURCE #{idx} CLASSIFICATION:",
                "-" * 70,
                f"  Source ID: {classification['source_id']}",
                f"  Jamming Type: {classification['name']}",
                f"  Threat Level: {classification['threat_level'].upper()}",
                "",
                f"  Description:",
                f"    {classification['description']}",
                "",
                f"  Technical Parameters:",
                f"    • Frequency: {classification['frequency_mhz']:.2f} MHz",
                f"    • Power: {classification['power_dbm']:.1f} dBm"
            ])
            
            location = classification['location']
            if location:
                report_lines.append(
                    f"    • Location: {location.get('lat', 0):.4f}N, {location.get('lon', 0):.4f}E"
                )
            
            affected = ', '.join(classification['affected_systems'])
            report_lines.extend([
                f"    • Affected Systems: {affected}",
                ""
            ])
            
            # Recommended countermeasures
            countermeasures = classification['recommended_countermeasures']
            if countermeasures:
                report_lines.extend([
                    f"  Recommended Countermeasures:",
                    f"    (Ranked by effectiveness)"
                ])
                
                for cm in countermeasures:
                    effectiveness = cm.get('effectiveness', 0)
                    measure = cm.get('measure', 'unknown')
                    description = cm.get('description', 'No description')
                    
                    report_lines.extend([
                        f"",
                        f"    {effectiveness}% Effective - {measure.upper().replace('_', ' ')}",
                        f"      → {description}"
                    ])
            
            report_lines.append("")
        
        # Summary recommendations
        report_lines.extend([
            "=" * 70,
            "SUMMARY RECOMMENDATIONS:",
            "-" * 70
        ])
        
        summary_recs = self._generate_summary_recommendations(classified_sources, overall_threat)
        for rec in summary_recs:
            report_lines.append(f"  → {rec}")
        
        report_lines.extend([
            "",
            "=" * 70,
            f"CLASSIFICATION COMPLETE - {overall_threat['level'].upper()} threat detected",
            "Recommend immediate tactical response planning"
        ])
        
        return "\n".join(report_lines)
    
    def _assess_overall_threat(self, classified_sources: List[Dict]) -> Dict:
        """Assess overall threat level from all sources"""
        threat_levels = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0
        }
        
        for source in classified_sources:
            level = source['threat_level'].lower()
            if level in threat_levels:
                threat_levels[level] += 1
        
        # Calculate overall threat
        if threat_levels['critical'] > 0:
            overall_level = 'critical'
            score = 90 + min(threat_levels['critical'] * 2, 10)
        elif threat_levels['high'] > 0:
            overall_level = 'high'
            score = 70 + min(threat_levels['high'] * 5, 20)
        elif threat_levels['medium'] > 0:
            overall_level = 'medium'
            score = 40 + min(threat_levels['medium'] * 10, 30)
        else:
            overall_level = 'low'
            score = 20 + min(threat_levels['low'] * 10, 20)
        
        return {
            'level': overall_level,
            'score': min(score, 100),
            'critical_count': threat_levels['critical'],
            'high_count': threat_levels['high'],
            'medium_count': threat_levels['medium'],
            'low_count': threat_levels['low']
        }
    
    def _generate_summary_recommendations(
        self,
        classified_sources: List[Dict],
        overall_threat: Dict
    ) -> List[str]:
        """Generate summary recommendations based on classified sources"""
        recommendations = []
        
        # Collect all recommended countermeasures
        all_countermeasures = {}
        for source in classified_sources:
            for cm in source['recommended_countermeasures']:
                measure = cm.get('measure', 'unknown')
                effectiveness = cm.get('effectiveness', 0)
                
                if measure not in all_countermeasures:
                    all_countermeasures[measure] = {
                        'max_effectiveness': effectiveness,
                        'count': 1,
                        'description': cm.get('description', '')
                    }
                else:
                    all_countermeasures[measure]['count'] += 1
                    all_countermeasures[measure]['max_effectiveness'] = max(
                        all_countermeasures[measure]['max_effectiveness'],
                        effectiveness
                    )
        
        # Sort by effectiveness and frequency
        sorted_measures = sorted(
            all_countermeasures.items(),
            key=lambda x: (x[1]['max_effectiveness'], x[1]['count']),
            reverse=True
        )
        
        # Generate recommendations based on threat level
        if overall_threat['level'] == 'critical':
            recommendations.append(
                "IMMEDIATE ACTION REQUIRED: Multiple critical threats detected"
            )
            recommendations.append(
                "Deploy most effective countermeasures across all sources"
            )
        elif overall_threat['level'] == 'high':
            recommendations.append(
                "PRIORITY ACTION: Significant jamming threat detected"
            )
            recommendations.append(
                "Implement countermeasures within 30 seconds"
            )
        
        # Add top countermeasures
        recommendations.append("")
        recommendations.append("Priority Countermeasures (by effectiveness):")
        
        for idx, (measure, info) in enumerate(sorted_measures[:5], 1):
            measure_name = measure.replace('_', ' ').title()
            effectiveness = info['max_effectiveness']
            count = info['count']
            
            recommendations.append(
                f"  {idx}. {measure_name} ({effectiveness}% effective) "
                f"- Effective against {count} source{'s' if count > 1 else ''}"
            )
        
        # Tactical guidance
        recommendations.append("")
        
        if overall_threat['critical_count'] > 0:
            recommendations.append(
                "Consider kinetic neutralization for critical threats if location known"
            )
        
        if len(classified_sources) > 2:
            recommendations.append(
                "Multiple sources detected - prioritize most threatening emitters"
            )
        
        if overall_threat['level'] in ['critical', 'high']:
            recommendations.append(
                "Alert command authority - situation may require escalation"
            )
        
        return recommendations