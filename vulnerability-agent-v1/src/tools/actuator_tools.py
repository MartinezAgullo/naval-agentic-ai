"""
Actuator Tools for Countermeasure Execution
Dummy/placeholder tools that simulate execution of countermeasures
These tools represent actual ship systems that would execute the responses
"""

import json
import os
import time
import random
from typing import Type, Optional, Dict
from crewai.tools import BaseTool
from pydantic import BaseModel, Field

from src.utils.logger import get_logger

logger = get_logger(__name__)


# ============================================================================
# INPUT SCHEMAS
# ============================================================================

class ECMActuatorInput(BaseModel):
    """Input for ECM actuator"""
    target_source_id: str = Field(..., description="Target jamming source ID")
    power_level: str = Field("high", description="ECM power level (low/medium/high)")
    frequency_mhz: float = Field(..., description="Target frequency in MHz")


class FrequencyHopActuatorInput(BaseModel):
    """Input for frequency hopping"""
    systems: str = Field(..., description="Systems to apply frequency hopping (comma-separated)")
    hop_rate: int = Field(100, description="Hops per second")


class PowerIncreaseActuatorInput(BaseModel):
    """Input for power increase"""
    system: str = Field(..., description="System to increase power")
    increase_db: float = Field(10.0, description="Power increase in dB")


class UAVActuatorInput(BaseModel):
    """Input for UAV deployment"""
    target_location: str = Field(..., description="Target location (lat,lon)")
    mission_type: str = Field("neutralization", description="Mission type")


class EvasiveManeuverActuatorInput(BaseModel):
    """Input for evasive maneuvers"""
    course_change: float = Field(..., description="Course change in degrees")
    speed_change: float = Field(0.0, description="Speed change in knots")


class EMCONActuatorInput(BaseModel):
    """Input for EMCON procedures"""
    level: str = Field("bravo", description="EMCON level (alpha/bravo/charlie)")
    systems_to_secure: str = Field("", description="Specific systems to secure")


# ============================================================================
# ECM ACTUATOR
# ============================================================================

class ECMActuator(BaseTool):
    """Executes Electronic Counter Measures against jamming source"""
    
    name: str = "ECM Actuator"
    description: str = (
        "Deploys directional electronic counter measures (ECM) against identified jamming source. "
        "Simulates active jamming/interference to degrade hostile emitter. "
        "Input: target_source_id, power_level, frequency_mhz"
    )
    args_schema: Type[BaseModel] = ECMActuatorInput
    
    def _run(self, target_source_id: str, power_level: str, frequency_mhz: float) -> str:
        try:
            logger.info(f"Executing ECM against source {target_source_id}")
            
            # Simulate execution time
            execution_time = random.uniform(3, 7)
            time.sleep(0.1)  # Brief pause for realism
            
            # Simulate success probability based on power level
            success_prob = {'low': 0.6, 'medium': 0.75, 'high': 0.9}.get(power_level, 0.75)
            success = random.random() < success_prob
            
            effectiveness = random.randint(70, 95) if success else random.randint(30, 60)
            
            report = f"""
==================================================
ECM EXECUTION REPORT
==================================================
Target Source: {target_source_id}
Target Frequency: {frequency_mhz:.2f} MHz
ECM Power Level: {power_level.upper()}
Execution Time: {execution_time:.1f} seconds

RESULT: {'SUCCESS' if success else 'PARTIAL'}
Effectiveness: {effectiveness}%

STATUS:
{'✓ ECM deployed successfully' if success else '⚠ ECM deployed with reduced effectiveness'}
{'✓ Hostile signal degraded' if success else '⚠ Hostile signal partially degraded'}
{'✓ Target jamming disrupted' if success else '⚠ Target jamming continues at reduced power'}

SIDE EFFECTS:
⚠ Own ship EM signature increased during ECM
⚠ Power consumption elevated

==================================================
ECM COUNTERMEASURE: {'EFFECTIVE' if success else 'MARGINAL'}
==================================================
"""
            logger.info(f"ECM execution {'successful' if success else 'partial'}")
            return report.strip()
            
        except Exception as e:
            logger.error(f"ECM execution error: {e}", exc_info=True)
            return f"ERROR: ECM execution failed - {str(e)}"


# ============================================================================
# FREQUENCY HOP ACTUATOR
# ============================================================================

class FrequencyHopActuator(BaseTool):
    """Executes frequency hopping on communication systems"""
    
    name: str = "Frequency Hop Actuator"
    description: str = (
        "Activates frequency hopping protocols on specified communication systems. "
        "Rapidly switches between frequencies to evade jamming. "
        "Input: systems (comma-separated), hop_rate"
    )
    args_schema: Type[BaseModel] = FrequencyHopActuatorInput
    
    def _run(self, systems: str, hop_rate: int) -> str:
        try:
            logger.info(f"Activating frequency hopping on {systems}")
            
            # Parse systems
            system_list = [s.strip() for s in systems.split(',')]
            
            # Simulate execution
            time.sleep(0.1)
            execution_time = random.uniform(1, 3)
            
            success = random.random() < 0.9  # High success rate
            effectiveness = random.randint(75, 95) if success else random.randint(40, 70)
            
            report = f"""
==================================================
FREQUENCY HOPPING EXECUTION REPORT
==================================================
Systems Affected: {len(system_list)}
"""
            
            for sys in system_list:
                report += f"  • {sys}\n"
            
            report += f"""
Hop Rate: {hop_rate} hops/second
Execution Time: {execution_time:.1f} seconds

RESULT: {'SUCCESS' if success else 'PARTIAL'}
Effectiveness: {effectiveness}%

FREQUENCY HOPPING STATUS:
"""
            
            for sys in system_list:
                report += f"{'✓' if success else '⚠'} {sys}: Frequency hopping ACTIVE\n"
            
            report += f"""
OPERATIONAL IMPACT:
✓ Jamming avoidance improved
✓ Communication continuity maintained
⚠ Requires coordination with task force
⚠ Slight increase in signal processing load

==================================================
FREQUENCY HOPPING: {'ACTIVE' if success else 'PARTIAL'}
==================================================
"""
            logger.info(f"Frequency hopping {'activated' if success else 'partially activated'}")
            return report.strip()
            
        except Exception as e:
            logger.error(f"Frequency hop execution error: {e}", exc_info=True)
            return f"ERROR: Frequency hopping failed - {str(e)}"


# ============================================================================
# POWER INCREASE ACTUATOR
# ============================================================================

class PowerIncreaseActuator(BaseTool):
    """Increases transmission power to burn through jamming"""
    
    name: str = "Power Increase Actuator"
    description: str = (
        "Increases transmission power on specified system to overcome jamming (burn-through). "
        "Input: system (name), increase_db (power increase in dB)"
    )
    args_schema: Type[BaseModel] = PowerIncreaseActuatorInput
    
    def _run(self, system: str, increase_db: float) -> str:
        try:
            logger.info(f"Increasing power on {system} by {increase_db} dB")
            
            # Simulate execution
            time.sleep(0.1)
            execution_time = random.uniform(0.5, 2)
            
            success = random.random() < 0.8
            effectiveness = random.randint(60, 85) if success else random.randint(30, 55)
            
            report = f"""
==================================================
POWER INCREASE EXECUTION REPORT
==================================================
System: {system}
Power Increase: +{increase_db} dB
Execution Time: {execution_time:.1f} seconds

RESULT: {'SUCCESS' if success else 'PARTIAL'}
Burn-Through Effectiveness: {effectiveness}%

POWER STATUS:
{'✓' if success else '⚠'} {system}: Power increased to {100 + increase_db:.0f}% nominal
{'✓ Signal strength improved' if success else '⚠ Signal strength partially improved'}
{'✓ Jamming resistance increased' if success else '⚠ Jamming partially overcome'}

SIDE EFFECTS:
⚠ EM signature increased by {increase_db * 1.5:.1f} dB
⚠ Power consumption increased by {(increase_db / 10) * 100:.0f}%
⚠ Thermal load elevated
⚠ Detection range to hostile sensors increased

SUSTAINABILITY:
Maximum sustainable duration: 60 minutes
Recommend return to normal power when threat reduced

==================================================
POWER INCREASE: {'EFFECTIVE' if success else 'MARGINAL'}
==================================================
"""
            logger.info(f"Power increase {'successful' if success else 'partial'}")
            return report.strip()
            
        except Exception as e:
            logger.error(f"Power increase execution error: {e}", exc_info=True)
            return f"ERROR: Power increase failed - {str(e)}"


# ============================================================================
# UAV ACTUATOR
# ============================================================================

class UAVActuator(BaseTool):
    """Deploys UAV to neutralize jamming source"""
    
    name: str = "UAV Actuator"
    description: str = (
        "Deploys unmanned aerial vehicle to locate and neutralize jamming source. "
        "Input: target_location (lat,lon string), mission_type"
    )
    args_schema: Type[BaseModel] = UAVActuatorInput
    
    def _run(self, target_location: str, mission_type: str) -> str:
        try:
            logger.info(f"Deploying UAV to {target_location} for {mission_type}")
            
            # Parse location
            try:
                lat, lon = [float(x.strip()) for x in target_location.split(',')]
            except:
                lat, lon = 0.0, 0.0
            
            # Simulate execution (UAVs take longer)
            time.sleep(0.2)
            execution_time = random.uniform(90, 150)
            
            success = random.random() < 0.85
            effectiveness = random.randint(85, 100) if success else random.randint(50, 75)
            
            report = f"""
==================================================
UAV DEPLOYMENT REPORT
==================================================
Mission Type: {mission_type.upper()}
Target Location: {lat:.4f}N, {lon:.4f}E
Launch Time: T+0s
Estimated Time to Target: {execution_time:.0f} seconds

UAV STATUS:
✓ UAV launched successfully
✓ En route to target location
✓ EW payload armed and ready
{'✓ Target acquired' if success else '⚠ Target area reached'}
{'✓ Neutralization complete' if success else '⚠ Partial neutralization'}

MISSION RESULT: {'SUCCESS' if success else 'PARTIAL'}
Target Neutralization: {effectiveness}%

OPERATIONAL STATUS:
"""
            
            if success:
                report += """✓ Jamming source eliminated
✓ Hostile emissions ceased
✓ Communications restored
✓ UAV returning to base
"""
            else:
                report += """⚠ Jamming source damaged but operational
⚠ Hostile emissions reduced
⚠ Communications partially restored
⚠ UAV loitering for follow-up strike
"""
            
            report += f"""
RESOURCE EXPENDITURE:
• 1 UAV deployed
• EW/Kinetic payload expended
• Flight time: {execution_time / 60:.1f} minutes

==================================================
UAV MISSION: {'SUCCESSFUL' if success else 'PARTIAL SUCCESS'}
==================================================
"""
            logger.info(f"UAV mission {'successful' if success else 'partial'}")
            return report.strip()
            
        except Exception as e:
            logger.error(f"UAV deployment error: {e}", exc_info=True)
            return f"ERROR: UAV deployment failed - {str(e)}"


# ============================================================================
# EVASIVE MANEUVER ACTUATOR
# ============================================================================

class EvasiveManeuverActuator(BaseTool):
    """Executes evasive ship maneuvers"""
    
    name: str = "Evasive Maneuver Actuator"
    description: str = (
        "Executes evasive course and speed changes to complicate hostile targeting. "
        "Input: course_change (degrees), speed_change (knots)"
    )
    args_schema: Type[BaseModel] = EvasiveManeuverActuatorInput
    
    def _run(self, course_change: float, speed_change: float) -> str:
        try:
            logger.info(f"Executing evasive maneuver: {course_change}° course change")
            
            # Simulate execution
            time.sleep(0.1)
            execution_time = random.uniform(20, 40)
            
            success = random.random() < 0.95  # Very high success rate
            effectiveness = random.randint(60, 80) if success else random.randint(30, 55)
            
            new_course = (180 + course_change) % 360  # Dummy new course
            new_speed = 25 + speed_change  # Dummy new speed
            
            report = f"""
==================================================
EVASIVE MANEUVER EXECUTION REPORT
==================================================
Maneuver Type: {'SUCCESSFUL' if success else 'PARTIAL'}
Course Change: {course_change:+.0f}°
Speed Change: {speed_change:+.1f} knots
Execution Time: {execution_time:.0f} seconds

NAVIGATION STATUS:
Previous Course: 180°
New Course: {new_course:.0f}°
Previous Speed: 25 knots
New Speed: {new_speed:.1f} knots

RESULT: {'SUCCESS' if success else 'PARTIAL'}
Evasion Effectiveness: {effectiveness}%

TACTICAL EFFECT:
"""
            
            if success:
                report += """✓ Course change executed smoothly
✓ Tracking disrupted for hostile sensors
✓ Targeting geometry complicated
✓ Ship positioning optimized
"""
            else:
                report += """⚠ Course change completed with minor delay
⚠ Tracking partially disrupted
⚠ Limited tactical advantage gained
"""
            
            report += f"""
OPERATIONAL IMPACT:
✓ Ship maneuvering freely
⚠ Transit time to destination increased
⚠ Fuel consumption elevated during maneuver

RECOMMEND:
Monitor hostile sensor tracking
Continue evasive pattern if threat persists

==================================================
EVASIVE MANEUVER: {'COMPLETE' if success else 'PARTIAL'}
==================================================
"""
            logger.info(f"Evasive maneuver {'successful' if success else 'partial'}")
            return report.strip()
            
        except Exception as e:
            logger.error(f"Evasive maneuver error: {e}", exc_info=True)
            return f"ERROR: Evasive maneuver failed - {str(e)}"


# ============================================================================
# EMCON ACTUATOR
# ============================================================================

class EMCONActuator(BaseTool):
    """Implements Emission Control (EMCON) procedures"""
    
    name: str = "EMCON Actuator"
    description: str = (
        "Implements emission control procedures to reduce electromagnetic signature. "
        "Input: level (alpha/bravo/charlie), systems_to_secure"
    )
    args_schema: Type[BaseModel] = EMCONActuatorInput
    
    def _run(self, level: str, systems_to_secure: str) -> str:
        try:
            logger.info(f"Implementing EMCON {level.upper()}")
            
            # Simulate execution
            time.sleep(0.1)
            execution_time = random.uniform(5, 15)
            
            success = random.random() < 0.95
            
            # EMCON level descriptions
            emcon_levels = {
                'alpha': {
                    'description': 'Unrestricted emissions',
                    'signature_reduction': 10,
                    'systems_affected': []
                },
                'bravo': {
                    'description': 'Restricted emissions - non-essential secured',
                    'signature_reduction': 40,
                    'systems_affected': ['Non-essential radar', 'Secondary comms']
                },
                'charlie': {
                    'description': 'Minimal emissions - essential only',
                    'signature_reduction': 70,
                    'systems_affected': ['All radar', 'Most comms', 'Datalink']
                }
            }
            
            emcon_data = emcon_levels.get(level.lower(), emcon_levels['bravo'])
            
            report = f"""
==================================================
EMCON EXECUTION REPORT
==================================================
EMCON Level: {level.upper()}
Description: {emcon_data['description']}
Execution Time: {execution_time:.1f} seconds

RESULT: {'SUCCESS' if success else 'PARTIAL'}
EM Signature Reduction: {emcon_data['signature_reduction']}%

SYSTEMS STATUS:
"""
            
            if emcon_data['systems_affected']:
                for sys in emcon_data['systems_affected']:
                    report += f"{'✓' if success else '⚠'} {sys}: SECURED\n"
            else:
                report += "✓ All systems operational (EMCON Alpha)\n"
            
            report += f"""
ESSENTIAL SYSTEMS MAINTAINED:
✓ SATCOM (encrypted)
✓ Minimal radar for navigation
✓ Command & control datalink
✓ IFF (identification)

OPERATIONAL IMPACT:
{'✓ Signature significantly reduced' if success else '⚠ Signature partially reduced'}
⚠ Situational awareness limited
⚠ Communication bandwidth reduced
{'✓ Detection probability decreased' if success else '⚠ Detection probability somewhat decreased'}

DETECTABILITY:
Previous detection range: ~65 km
New detection range: ~{65 * (1 - emcon_data['signature_reduction'] / 100):.0f} km

DURATION:
EMCON {level.upper()} can be maintained indefinitely
Recommend reassess when threat reduced

==================================================
EMCON {level.upper()}: {'ACTIVE' if success else 'PARTIAL'}
==================================================
"""
            logger.info(f"EMCON {level.upper()} {'implemented' if success else 'partially implemented'}")
            return report.strip()
            
        except Exception as e:
            logger.error(f"EMCON execution error: {e}", exc_info=True)
            return f"ERROR: EMCON execution failed - {str(e)}"


# ============================================================================
# ALTERNATIVE CHANNEL ACTUATOR
# ============================================================================

class AlternativeChannelActuator(BaseTool):
    """Switches to alternative communication channels"""
    
    name: str = "Alternative Channel Actuator"
    description: str = (
        "Switches communications to backup/alternative channels to avoid jamming. "
        "Input: channel_type (SATCOM/UHF/laser), priority (high/medium/low)"
    )
    args_schema: Type[BaseModel] = BaseModel
    
    def _run(self, channel_type: str = "SATCOM", priority: str = "high") -> str:
        try:
            logger.info(f"Switching to alternative channel: {channel_type}")
            
            # Simulate execution
            time.sleep(0.1)
            execution_time = random.uniform(3, 8)
            
            success = random.random() < 0.9
            effectiveness = random.randint(80, 98) if success else random.randint(50, 75)
            
            report = f"""
==================================================
ALTERNATIVE CHANNEL SWITCH REPORT
==================================================
Target Channel: {channel_type.upper()}
Priority: {priority.upper()}
Execution Time: {execution_time:.1f} seconds

RESULT: {'SUCCESS' if success else 'PARTIAL'}
Channel Effectiveness: {effectiveness}%

CHANNEL STATUS:
"""
            
            if success:
                report += f"""✓ {channel_type.upper()} channel established
✓ Encryption enabled
✓ Signal quality: EXCELLENT
✓ Jamming avoided
✓ Full bandwidth available
"""
            else:
                report += f"""⚠ {channel_type.upper()} channel established with degradation
⚠ Encryption enabled
⚠ Signal quality: FAIR
⚠ Some interference present
⚠ Reduced bandwidth
"""
            
            report += f"""
COMMUNICATION STATUS:
✓ Command & control: OPERATIONAL
✓ Tactical coordination: OPERATIONAL
✓ Data transfer: {effectiveness}% capacity

ADVANTAGES:
✓ Outside jammed frequency bands
✓ Enhanced encryption
{'✓ High reliability' if success else '⚠ Moderate reliability'}
✓ Backup channels available

==================================================
CHANNEL SWITCH: {'SUCCESSFUL' if success else 'PARTIAL'}
==================================================
"""
            logger.info(f"Channel switch to {channel_type} {'successful' if success else 'partial'}")
            return report.strip()
            
        except Exception as e:
            logger.error(f"Channel switch error: {e}", exc_info=True)
            return f"ERROR: Channel switch failed - {str(e)}"