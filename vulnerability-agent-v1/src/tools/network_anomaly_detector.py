"""
Network Anomaly Detector Tool
Detects cybersecurity anomalies in ship network traffic that may indicate electronic attack
"""

import json
import os
from typing import Type, Optional, Dict
from crewai.tools import BaseTool
from pydantic import BaseModel, Field

from src.utils.logger import get_logger

logger = get_logger(__name__)


class NetworkAnomalyInput(BaseModel):
    """Input schema for network anomaly detection"""
    attack_data: str = Field(
        ...,
        description="JSON string or file path containing attack scenario with network anomalies"
    )


class NetworkAnomalyDetector(BaseTool):
    """Detects network-level anomalies indicating electronic warfare attack"""
    
    name: str = "Network Anomaly Detector"
    description: str = (
        "Analyzes ship network traffic for anomalies caused by electronic attacks. "
        "Detects packet loss, latency spikes, corrupted frames, and connection drops. "
        "Input: attack_data (JSON string or file path)"
    )
    args_schema: Type[BaseModel] = NetworkAnomalyInput
    
    def _run(self, attack_data: str) -> str:
        try:
            logger.info("Analyzing network traffic for anomalies")
            
            # Parse attack data
            data = self._parse_attack_data(attack_data)
            
            if not data:
                logger.error("Failed to parse attack data")
                return "ERROR: Could not parse attack data"
            
            # Extract network anomalies
            network_anomalies = data.get('network_anomalies', {})
            
            if not network_anomalies:
                logger.info("No network anomalies detected")
                return self._build_clean_report()
            
            # Analyze anomalies
            severity = self._assess_severity(network_anomalies)
            
            logger.info(f"Network anomalies detected - Severity: {severity}")
            
            report = self._build_anomaly_report(network_anomalies, severity, data)
            return report
            
        except Exception as e:
            logger.error(f"Network anomaly detection error: {e}", exc_info=True)
            return f"ERROR in network anomaly detection: {str(e)}"
    
    def _parse_attack_data(self, attack_data: str) -> Optional[Dict]:
        """Parse attack data from file or JSON string"""
        try:
            if os.path.exists(attack_data):
                logger.debug(f"Reading attack data from file: {attack_data}")
                with open(attack_data, 'r') as f:
                    return json.load(f)
            
            logger.debug("Parsing attack data as JSON string")
            return json.loads(attack_data)
        
        except Exception as e:
            logger.error(f"Failed to parse attack data: {e}")
            return None
    
    def _assess_severity(self, anomalies: Dict) -> str:
        """Assess severity of network anomalies"""
        packet_loss = anomalies.get('packet_loss', 0)
        latency = anomalies.get('latency_increase', 0)
        corrupted = anomalies.get('corrupted_frames', 0)
        drops = anomalies.get('connection_drops', 0)
        
        # Severity thresholds
        if packet_loss >= 50 or drops >= 10 or latency >= 500:
            return "CRITICAL"
        elif packet_loss >= 30 or drops >= 5 or latency >= 300:
            return "HIGH"
        elif packet_loss >= 15 or drops >= 2 or latency >= 150:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _build_anomaly_report(
        self,
        anomalies: Dict,
        severity: str,
        data: Dict
    ) -> str:
        """Build network anomaly detection report"""
        
        packet_loss = anomalies.get('packet_loss', 0)
        latency = anomalies.get('latency_increase', 0)
        corrupted = anomalies.get('corrupted_frames', 0)
        drops = anomalies.get('connection_drops', 0)
        bandwidth_deg = anomalies.get('bandwidth_degradation_percent', 0)
        
        # Determine affected services
        affected_services = self._identify_affected_services(anomalies)
        
        # Get timestamp
        timestamp = data.get('timestamp', 'Unknown')
        
        report_lines = [
            "=" * 70,
            "NETWORK ANOMALY DETECTION REPORT",
            "=" * 70,
            f"Detection Time: {timestamp}",
            f"Severity Level: {severity}",
            f"Analysis Status: COMPLETE",
            "",
            "DETECTED ANOMALIES:",
            "-" * 70,
            f"  • Packet Loss: {packet_loss}% {'⚠ CRITICAL' if packet_loss >= 50 else '⚠ HIGH' if packet_loss >= 30 else '⚠' if packet_loss >= 15 else ''}",
            f"  • Latency Increase: +{latency} ms {'⚠ CRITICAL' if latency >= 500 else '⚠ HIGH' if latency >= 300 else '⚠' if latency >= 150 else ''}",
            f"  • Corrupted Frames: {corrupted} {'⚠ HIGH' if corrupted >= 100 else '⚠' if corrupted >= 50 else ''}",
            f"  • Connection Drops: {drops} {'⚠ CRITICAL' if drops >= 10 else '⚠ HIGH' if drops >= 5 else '⚠' if drops >= 2 else ''}"
        ]
        
        if bandwidth_deg > 0:
            report_lines.append(
                f"  • Bandwidth Degradation: {bandwidth_deg}% {'⚠' if bandwidth_deg >= 30 else ''}"
            )
        
        report_lines.extend([
            "",
            "AFFECTED SERVICES:",
            "-" * 70
        ])
        
        for service in affected_services:
            report_lines.append(f"  ✗ {service}")
        
        report_lines.extend([
            "",
            "ANOMALY CHARACTERISTICS:",
            "-" * 70,
            f"  Attack Pattern: {self._identify_attack_pattern(anomalies)}",
            f"  Network Layer: {self._identify_affected_layer(anomalies)}",
            f"  Traffic Impact: {self._calculate_traffic_impact(anomalies)}%",
            "",
            "CORRELATION ANALYSIS:",
            "-" * 70
        ])
        
        # Check if there are jamming sources
        sources = data.get('sources', [])
        if sources:
            report_lines.append(
                f"  Correlation with RF jamming: CONFIRMED - {len(sources)} source(s) detected"
            )
            for source in sources:
                affected_systems = source.get('affected_systems', [])
                if 'communications' in affected_systems or 'datalink' in affected_systems:
                    report_lines.append(
                        f"    → Source {source.get('source_id', 'UNKNOWN')}: "
                        f"{source.get('jamming_type', 'unknown')} jamming at "
                        f"{source.get('frequency_mhz', 0):.2f} MHz"
                    )
        else:
            report_lines.append("  Correlation with RF jamming: UNKNOWN - No RF data available")
        
        report_lines.extend([
            "",
            "ASSESSMENT:",
            "-" * 70,
            self._get_assessment_text(severity, anomalies),
            "",
            "IMMEDIATE ACTIONS REQUIRED:",
            "-" * 70
        ])
        
        # Recommendations based on severity
        recommendations = self._get_recommendations(severity, anomalies)
        for rec in recommendations:
            report_lines.append(f"  → {rec}")
        
        report_lines.extend([
            "",
            "=" * 70,
            f"CONCLUSION: Network under electronic attack - {severity} severity",
            "Recommend immediate countermeasure evaluation"
        ])
        
        return "\n".join(report_lines)
    
    def _build_clean_report(self) -> str:
        """Build report when no anomalies detected"""
        return """
=======================================================================
NETWORK ANOMALY DETECTION REPORT
=======================================================================
Analysis Status: COMPLETE
Severity Level: NONE

NETWORK STATUS: NOMINAL

No anomalies detected in network traffic.
All communication channels operating within normal parameters.

Packet Loss: <1%
Latency: Normal
Throughput: Nominal
Connection Stability: EXCELLENT

=======================================================================
CONCLUSION: Network operating normally - no electronic attack detected
"""
    
    def _identify_affected_services(self, anomalies: Dict) -> list:
        """Identify which services are affected by anomalies"""
        packet_loss = anomalies.get('packet_loss', 0)
        latency = anomalies.get('latency_increase', 0)
        
        affected = []
        
        if packet_loss >= 20:
            affected.append("Voice Communications (VoIP)")
            affected.append("Video Feeds (ISR)")
        
        if latency >= 200:
            affected.append("Real-time Tactical Datalink")
            affected.append("Command & Control Systems")
        
        if packet_loss >= 30 or latency >= 300:
            affected.append("Sensor Data Fusion")
            affected.append("Fire Control Systems")
        
        if not affected:
            affected.append("Minor impact on non-critical services")
        
        return affected
    
    def _identify_attack_pattern(self, anomalies: Dict) -> str:
        """Identify the attack pattern from anomalies"""
        packet_loss = anomalies.get('packet_loss', 0)
        latency = anomalies.get('latency_increase', 0)
        drops = anomalies.get('connection_drops', 0)
        
        if packet_loss >= 50 and drops >= 5:
            return "Aggressive jamming (complete disruption)"
        elif packet_loss >= 30 and latency >= 300:
            return "Mixed jamming (degradation + disruption)"
        elif latency >= 300:
            return "Saturation attack (bandwidth exhaustion)"
        elif drops >= 5:
            return "Intermittent jamming (pulsed interference)"
        else:
            return "Low-intensity interference"
    
    def _identify_affected_layer(self, anomalies: Dict) -> str:
        """Identify which network layer is affected"""
        corrupted = anomalies.get('corrupted_frames', 0)
        drops = anomalies.get('connection_drops', 0)
        
        if corrupted >= 100:
            return "Physical/Data Link Layer (RF interference)"
        elif drops >= 5:
            return "Transport/Network Layer (connection stability)"
        else:
            return "Multiple layers affected"
    
    def _calculate_traffic_impact(self, anomalies: Dict) -> int:
        """Calculate overall traffic impact percentage"""
        packet_loss = anomalies.get('packet_loss', 0)
        bandwidth_deg = anomalies.get('bandwidth_degradation_percent', 0)
        
        # Average impact
        impact = (packet_loss + bandwidth_deg) / 2
        return int(impact)
    
    def _get_assessment_text(self, severity: str, anomalies: Dict) -> str:
        """Get assessment text based on severity"""
        assessments = {
            'CRITICAL': (
                "Network communications are severely compromised. Mission-critical systems "
                "experiencing catastrophic degradation. Immediate countermeasures required "
                "to restore operational capability."
            ),
            'HIGH': (
                "Significant network degradation detected. Key communication systems are "
                "impacted. Operational effectiveness is reduced. Priority countermeasures "
                "recommended."
            ),
            'MEDIUM': (
                "Moderate network interference detected. Non-critical systems affected. "
                "Operational capability maintained but degraded. Countermeasures should "
                "be considered."
            ),
            'LOW': (
                "Minor network anomalies detected. Minimal impact on operations. "
                "Situation should be monitored for escalation."
            )
        }
        
        return assessments.get(severity, "Unknown severity level")
    
    def _get_recommendations(self, severity: str, anomalies: Dict) -> list:
        """Get recommendations based on severity"""
        if severity == 'CRITICAL':
            return [
                "Switch to backup SATCOM channels immediately",
                "Activate frequency hopping on all tactical links",
                "Increase transmission power (burn-through attempt)",
                "Locate and neutralize jamming source with UAV",
                "Implement EMCON procedures for non-essential systems"
            ]
        elif severity == 'HIGH':
            return [
                "Switch to alternative communication frequencies",
                "Increase encryption strength on active channels",
                "Deploy directional antennas toward key nodes",
                "Prepare backup communication methods",
                "Alert electronic warfare team for countermeasures"
            ]
        elif severity == 'MEDIUM':
            return [
                "Monitor network metrics for escalation",
                "Prepare frequency hopping protocols",
                "Test backup communication channels",
                "Increase network redundancy"
            ]
        else:  # LOW
            return [
                "Continue monitoring network status",
                "Document anomaly patterns for analysis",
                "Maintain heightened alert status"
            ]