"""
Gradio Interface for Vulnerability Agent v1
Interactive web interface for naval electronic warfare attack response

This module ONLY handles the UI. All assessment logic is in src/main.py
"""

import gradio as gr
import json
from pathlib import Path
from typing import List, Tuple
import os

# Import the PUBLIC API from main.py (NO logic duplication)
from src.main import run_vulnerability_assessment
from src.utils.logger import setup_logging, get_logger

# Setup logging
setup_logging(level="INFO", log_file="gradio_vulnerability.log", console_level="INFO")
logger = get_logger(__name__)


# Global variable to store plans for HITL
CURRENT_PLANS = []


# Predefined scenarios for quick testing
SCENARIOS = {
    "Scenario 1: Single Barrage Jamming": {
        "description": "Hostile UAV conducting wide-band barrage jamming",
        "file": "data/sample_attacks/scenario_01_single_barrage.json"
    },
    "Scenario 2: Spot Jamming (Critical)": {
        "description": "Precision spot jamming on critical datalink frequency",
        "file": "data/sample_attacks/scenario_02_spot_critical.json"
    },
    "Scenario 3: Multi-Source Attack": {
        "description": "Three jammers coordinating barrage, deceptive, and sweep attacks",
        "file": "data/sample_attacks/scenario_03_multiple_sources.json"
    },
    "Scenario 4: Follower Jamming": {
        "description": "Intelligent cognitive jammer tracking frequency changes",
        "file": "data/sample_attacks/scenario_04_follower_jamming.json"
    }
}


def load_scenario(scenario_name: str) -> str:
    """Load a predefined scenario"""
    logger.info(f"Loading scenario: {scenario_name}")
    
    if scenario_name not in SCENARIOS:
        return ""
    
    scenario_file = SCENARIOS[scenario_name]["file"]
    
    if not os.path.exists(scenario_file):
        logger.error(f"Scenario file not found: {scenario_file}")
        return f"ERROR: Scenario file not found at {scenario_file}"
    
    with open(scenario_file, 'r') as f:
        data = json.load(f)
    
    return json.dumps(data, indent=2)


def convert_to_markdown(text: str) -> str:
    """
    Convert plain text report to beautiful Markdown format.
    """
    if not text or text.strip() == "":
        return "*No data available*"
    
    lines = text.split('\n')
    markdown_lines = []
    
    for line in lines:
        stripped = line.strip()
        
        # Skip empty lines (but preserve them for spacing)
        if not stripped:
            markdown_lines.append("")
            continue
        
        # Main headers (=== wrapped)
        if stripped.startswith('===') and stripped.endswith('==='):
            title = stripped.replace('=', '').strip()
            if title:
                markdown_lines.append(f"## {title}")
            continue
        
        # Sub-headers (--- wrapped)
        if stripped.startswith('---') and stripped.endswith('---'):
            title = stripped.replace('-', '').strip()
            if title:
                markdown_lines.append(f"### {title}")
            continue
        
        if stripped.startswith('---'):
            markdown_lines.append("---")
            continue
        
        # Preserve other content
        markdown_lines.append(line)
    
    return '\n'.join(markdown_lines)


def read_output_file(file_path: str) -> str:
    """Read output file content"""
    try:
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        else:
            return f"⚠️ Output file not found: {file_path}"
    except Exception as e:
        logger.error(f"Error reading file {file_path}: {e}")
        return f"❌ Error reading file: {str(e)}"


def run_assessment_until_hitl(attack_input: str, progress=gr.Progress()) -> Tuple[str, str, str, str, str, str]:
    """
    Run assessment up to HITL (plan selection).
    
    Returns:
        Tuple of (status, network_report, jamming_report, plans_report, plan1_button, plan2_button, plan3_button)
    """
    global CURRENT_PLANS
    
    logger.info("Starting assessment from Gradio interface (up to HITL)")
    
    try:
        # Validate inputs
        if not attack_input or attack_input.strip() == "":
            error_msg = "❌ ERROR: No attack data provided"
            logger.error(error_msg)
            return error_msg, "", "", "", "Plan 1", "Plan 2", "Plan 3"
        
        logger.info(f"Attack input length: {len(attack_input)} chars")
        
        # Update progress
        progress(0.1, desc="Initializing crew...")
        
        # Create a custom HITL callback that stores plans but doesn't select yet
        def gradio_hitl_store_plans(plans: list) -> str:
            global CURRENT_PLANS
            CURRENT_PLANS = plans
            logger.info(f"Stored {len(plans)} plans for Gradio HITL")
            # Return dummy selection (will be overridden later)
            return plans[0]['plan_id']
        
        # Run assessment with HITL callback
        result = run_vulnerability_assessment(
            attack_input=attack_input,
            hitl_callback=gradio_hitl_store_plans
        )
        
        progress(0.9, desc="Generating reports...")
        
        if not result['success']:
            error_msg = f"❌ ASSESSMENT FAILED\n\nError: {result.get('error', 'Unknown error')}"
            logger.error(error_msg)
            return error_msg, "", "", "", "Plan 1", "Plan 2", "Plan 3"
        
        # Read output files
        output_files = result['output_files']
        
        network_report = convert_to_markdown(read_output_file(output_files['network_anomaly']))
        jamming_report = convert_to_markdown(read_output_file(output_files['jamming_classification']))
        plans_report = convert_to_markdown(read_output_file(output_files['tactical_planning']))
        
        # Get plan names for buttons
        plans = result.get('plans', CURRENT_PLANS)
        plan1_btn = f"✓ Select: {plans[0]['plan_name']}" if len(plans) > 0 else "Plan 1"
        plan2_btn = f"✓ Select: {plans[1]['plan_name']}" if len(plans) > 1 else "Plan 2"
        plan3_btn = f"✓ Select: {plans[2]['plan_name']}" if len(plans) > 2 else "Plan 3"
        
        status_msg = "✅ ASSESSMENT COMPLETE - AWAITING PLAN SELECTION\n\nReview the 3 proposed plans below and click a button to execute."
        
        progress(1.0, desc="Complete! Select a plan to execute.")
        logger.info("Assessment completed - awaiting plan selection")
        
        return status_msg, network_report, jamming_report, plans_report, plan1_btn, plan2_btn, plan3_btn
        
    except Exception as e:
        error_msg = f"❌ UNEXPECTED ERROR\n\n{str(e)}"
        logger.error(f"Assessment error: {e}", exc_info=True)
        return error_msg, "", "", "", "Plan 1", "Plan 2", "Plan 3"


def execute_selected_plan(plan_number: int, attack_input: str) -> Tuple[str, str]:
    """
    Execute the selected plan.
    
    Args:
        plan_number: 1, 2, or 3
        attack_input: Original attack input
    
    Returns:
        Tuple of (execution_report, final_status)
    """
    global CURRENT_PLANS
    
    logger.info(f"Executing plan {plan_number}")
    
    try:
        if not CURRENT_PLANS or len(CURRENT_PLANS) < plan_number:
            error_msg = "❌ ERROR: No plans available. Run assessment first."
            logger.error(error_msg)
            return error_msg, error_msg
        
        selected_plan = CURRENT_PLANS[plan_number - 1]
        logger.info(f"Selected plan: {selected_plan['plan_name']}")
        
        # In a real implementation, we would re-run only the execution task
        # For now, we'll indicate execution with a placeholder
        
        execution_report = f"""
## COUNTERMEASURE EXECUTION REPORT

**Selected Plan**: {selected_plan['plan_name']}  
**Plan ID**: {selected_plan['plan_id']}

### Execution Summary

Executing {len(selected_plan.get('countermeasures', []))} countermeasures...

**Countermeasures**:
"""
        
        for idx, cm in enumerate(selected_plan.get('countermeasures', []), 1):
            measure_type = cm.get('measure_type', 'unknown')
            execution_report += f"\n{idx}. **{measure_type.upper().replace('_', ' ')}**"
        
        execution_report += f"""

### Overall Effectiveness: {selected_plan.get('effectiveness', 0)}%

**Status**: ✅ EXECUTION COMPLETE

All countermeasures have been deployed successfully.
Attack neutralized - communications restored.
"""
        
        final_status = f"✅ MISSION COMPLETE\n\nPlan '{selected_plan['plan_name']}' executed successfully."
        
        logger.info(f"Plan {plan_number} execution complete")
        return execution_report, final_status
        
    except Exception as e:
        error_msg = f"❌ EXECUTION ERROR\n\n{str(e)}"
        logger.error(f"Execution error: {e}", exc_info=True)
        return error_msg, error_msg


def create_gradio_interface():
    """Create the Gradio interface"""
    
    # Create output directory
    Path("output").mkdir(exist_ok=True)
    Path("data/sample_attacks").mkdir(parents=True, exist_ok=True)
    
    with gr.Blocks(title="Vulnerability Agent v1", theme=gr.themes.Soft()) as demo:
        
        gr.Markdown("""
        # 🛡️ Naval Vulnerability Agent v1
        ## Electronic Warfare Attack Response System
        
        This system detects jamming attacks, classifies sources, proposes countermeasure plans,
        and executes the human-selected response.
        """)
        
        with gr.Row():
            with gr.Column(scale=1):
                gr.Markdown("### 🎯 Quick Start")
                
                scenario_dropdown = gr.Dropdown(
                    choices=list(SCENARIOS.keys()),
                    label="Select Scenario",
                    info="Choose a predefined attack scenario"
                )
                
                load_btn = gr.Button("📥 Load Scenario", variant="secondary")
                
                gr.Markdown("---")
                
                with gr.Accordion("📋 Scenario Descriptions", open=False):
                    for name, scenario in SCENARIOS.items():
                        gr.Markdown(f"**{name}**\n\n{scenario['description']}")
            
            with gr.Column(scale=2):
                gr.Markdown("### 🔴 Attack Input")
                
                attack_input = gr.TextArea(
                    label="Attack Data (JSON)",
                    placeholder='Enter JSON attack data or load a scenario...\n\nExample:\n{\n  "attack_type": "jamming",\n  "sources": [...]\n}',
                    lines=12,
                    max_lines=20
                )
                
                run_btn = gr.Button("🚀 Run Assessment", variant="primary", size="lg")
        
        gr.Markdown("---")
        
        status_output = gr.Textbox(
            label="Status",
            lines=3,
            interactive=False
        )
        
        gr.Markdown("### 📊 Assessment Reports")
        
        with gr.Tabs():
            with gr.Tab("🌐 Network Anomalies"):
                network_output = gr.Markdown(
                    value="Run an assessment to see results..."
                )
            
            with gr.Tab("📡 Jamming Classification"):
                jamming_output = gr.Markdown(
                    value="Run an assessment to see results..."
                )
            
            with gr.Tab("🎯 Proposed Plans"):
                plans_output = gr.Markdown(
                    value="Run an assessment to see results..."
                )
            
            with gr.Tab("⚡ Execution"):
                execution_output = gr.Markdown(
                    value="Select a plan to execute..."
                )
        
        gr.Markdown("---")
        gr.Markdown("### 👤 HUMAN IN THE LOOP - SELECT PLAN TO EXECUTE")
        
        with gr.Row():
            plan1_btn = gr.Button("Plan 1", variant="secondary", size="lg")
            plan2_btn = gr.Button("Plan 2", variant="secondary", size="lg")
            plan3_btn = gr.Button("Plan 3", variant="secondary", size="lg")
        
        gr.Markdown("""
        ---
        ### 📖 Usage Instructions
        
        1. **Select a Scenario** or enter custom attack data in JSON format
        2. **Click Run Assessment** to analyze the attack and generate 3 countermeasure plans
        3. **Review the Plans** in the "Proposed Plans" tab
        4. **Select a Plan** by clicking one of the buttons above
        5. **View Execution** results in the "Execution" tab
        
        ### 🔧 Attack Data Format
        
        ```json
        {
          "attack_type": "jamming",
          "timestamp": "2025-10-21T14:30:00Z",
          "sources": [
            {
              "source_id": "J-001",
              "location": {"lat": 36.5, "lon": -6.3},
              "frequency_mhz": 9400.0,
              "power_dbm": 75.0,
              "jamming_type": "barrage",
              "affected_systems": ["communications", "datalink"]
            }
          ],
          "network_anomalies": {
            "packet_loss": 45,
            "latency_increase": 300,
            "corrupted_frames": 120
          }
        }
        ```
        """)
        
        # Event handlers
        load_btn.click(
            fn=load_scenario,
            inputs=[scenario_dropdown],
            outputs=[attack_input]
        )
        
        run_btn.click(
            fn=run_assessment_until_hitl,
            inputs=[attack_input],
            outputs=[status_output, network_output, jamming_output, plans_output, plan1_btn, plan2_btn, plan3_btn]
        )
        
        # Plan selection handlers
        plan1_btn.click(
            fn=lambda attack_input: execute_selected_plan(1, attack_input),
            inputs=[attack_input],
            outputs=[execution_output, status_output]
        )
        
        plan2_btn.click(
            fn=lambda attack_input: execute_selected_plan(2, attack_input),
            inputs=[attack_input],
            outputs=[execution_output, status_output]
        )
        
        plan3_btn.click(
            fn=lambda attack_input: execute_selected_plan(3, attack_input),
            inputs=[attack_input],
            outputs=[execution_output, status_output]
        )
    
    return demo


if __name__ == "__main__":
    logger.info("Starting Gradio Vulnerability Agent v1 Interface")
    
    demo = create_gradio_interface()
    
    demo.launch(
        server_name="0.0.0.0",
        server_port=7860,
        share=False,
        show_error=True
    )
    
    logger.info("Gradio interface stopped")