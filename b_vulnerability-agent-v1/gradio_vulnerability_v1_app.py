"""
Gradio Interface for Vulnerability Agent v1
Interactive web interface for naval electronic warfare attack response

This module ONLY handles the UI. All assessment logic is in src/main.py
"""

import gradio as gr
import json
from pathlib import Path
from typing import List, Tuple
import os

# Import the PUBLIC API from main.py (NO logic duplication)
from src.main import run_vulnerability_assessment
from src.utils.logger import setup_logging, get_logger

# Setup logging
setup_logging(level="INFO", log_file="gradio_vulnerability.log", console_level="INFO")
logger = get_logger(__name__)


# Global variable to store plans for HITL
CURRENT_PLANS = []


# Predefined scenarios for quick testing
SCENARIOS = {
    "Scenario 1: Single Barrage Jamming": {
        "description": "Hostile UAV conducting wide-band barrage jamming",
        "file": "data/sample_attacks/scenario_01_single_barrage.json"
    },
    "Scenario 2: Spot Jamming (Critical)": {
        "description": "Precision spot jamming on critical datalink frequency",
        "file": "data/sample_attacks/scenario_02_spot_critical.json"
    },
    "Scenario 3: Multi-Source Attack": {
        "description": "Three jammers coordinating barrage, deceptive, and sweep attacks",
        "file": "data/sample_attacks/scenario_03_multiple_sources.json"
    },
    "Scenario 4: Follower Jamming": {
        "description": "Intelligent cognitive jammer tracking frequency changes",
        "file": "data/sample_attacks/scenario_04_follower_jamming.json"
    }
}


def load_scenario(scenario_name: str) -> str:
    """Load a predefined scenario"""
    logger.info(f"Loading scenario: {scenario_name}")
    
    if scenario_name not in SCENARIOS:
        return ""
    
    scenario_file = SCENARIOS[scenario_name]["file"]
    
    if not os.path.exists(scenario_file):
        logger.error(f"Scenario file not found: {scenario_file}")
        return f"ERROR: Scenario file not found at {scenario_file}"
    
    with open(scenario_file, 'r') as f:
        data = json.load(f)
    
    return json.dumps(data, indent=2)


def convert_json_plans_to_markdown(data: dict) -> str:
    """
    Convert tactical plans JSON to formatted Markdown.
    """
    if "plans" not in data:
        return "*Invalid plan data*"
    
    lines = ["## TACTICAL COUNTERMEASURE PLANS\n"]
    
    for idx, plan in enumerate(data["plans"], 1):
        plan_id = plan.get("Plan ID", f"PLAN-{idx:03d}")
        plan_name = plan.get("Plan Name", "Unknown")
        effectiveness = plan.get("Overall Effectiveness", 0)
        exec_time = plan.get("Execution Time", "N/A")
        resource_cost = plan.get("Resource Cost", "Unknown")
        
        # Plan header with visual indicator
        if effectiveness >= 80:
            eff_icon = "üü¢"
        elif effectiveness >= 60:
            eff_icon = "üü°"
        else:
            eff_icon = "üü†"
        
        lines.append(f"### {eff_icon} Plan {idx}: {plan_name}")
        lines.append(f"**ID:** `{plan_id}` | **Effectiveness:** `{effectiveness}%` | **Time:** `{exec_time}s` | **Cost:** `{resource_cost}`\n")
        
        # Countermeasures
        countermeasures = plan.get("Countermeasures", [])
        if countermeasures:
            lines.append("**Countermeasures:**")
            for cm in countermeasures:
                cm_type = cm.get("Type", "unknown").upper().replace("_", " ")
                target = cm.get("Target", "N/A")
                cm_eff = cm.get("Estimated Effectiveness", 0)
                lines.append(f"- **{cm_type}** ‚Üí Target: `{target}` | Effectiveness: `{cm_eff}%`")
            lines.append("")
        
        # Pros
        pros = plan.get("PROS", [])
        if pros:
            lines.append("**‚úÖ Advantages:**")
            for pro in pros:
                lines.append(f"- {pro}")
            lines.append("")
        
        # Cons
        cons = plan.get("CONS", [])
        if cons:
            lines.append("**‚ö†Ô∏è Risks:**")
            for con in cons:
                lines.append(f"- {con}")
            lines.append("")
        
        lines.append("---\n")
    
    return "\n".join(lines)


def convert_to_markdown(text: str) -> str:
    """
    Convert plain text or JSON report to clean, structured Markdown format.
    
    Handles:
    - JSON tactical plans ‚Üí Formatted plan cards
    - === HEADER === lines ‚Üí ## Headers
    - --- subheaders --- ‚Üí ### Subheaders
    - [SECTION] markers ‚Üí ### Sections
    - Key: Value pairs ‚Üí **Key:** Value with status icons
    - Checkboxes, bullets, and special markers
    """
    if not text or text.strip() == "":
        return "*No data available*"
    
    text = text.strip()
    
    # Check if it's JSON (tactical plans)
    if text.startswith("{") or text.startswith("["):
        try:
            data = json.loads(text)
            if isinstance(data, dict) and "plans" in data:
                return convert_json_plans_to_markdown(data)
            # For other JSON, pretty print it
            return f"```json\n{json.dumps(data, indent=2)}\n```"
        except json.JSONDecodeError:
            pass  # Not valid JSON, process as text
    
    lines = text.split('\n')
    markdown_lines = []
    
    for line in lines:
        stripped = line.strip()
        
        # Skip pure separator lines (only = or -)
        if stripped and all(c == '=' for c in stripped):
            continue
        if stripped and all(c == '-' for c in stripped):
            markdown_lines.append("")
            continue
        
        # Empty lines
        if not stripped:
            markdown_lines.append("")
            continue
        
        # Main headers: === TITLE === or lines containing title wrapped in ===
        if '===' in stripped:
            title = stripped.replace('=', '').strip()
            if title:
                markdown_lines.append(f"\n## {title}\n")
            continue
        
        # Sub-headers: --- TITLE --- 
        if stripped.startswith('---') and stripped.endswith('---'):
            title = stripped.replace('-', '').strip()
            if title:
                markdown_lines.append(f"\n### {title}\n")
            continue
        
        # Section markers: [SECTION NAME] or SECTION NAME ---
        if stripped.startswith('[') and ']' in stripped:
            section_end = stripped.index(']')
            section_name = stripped[1:section_end]
            remainder = stripped[section_end + 1:].replace('-', '').strip()
            markdown_lines.append(f"\n### {section_name}\n")
            if remainder and not remainder.startswith('['):
                markdown_lines.append(remainder)
            continue
        
        # Numbered sections like "SOURCE #1 CLASSIFICATION"
        if stripped.endswith('---') and not stripped.startswith('-'):
            title = stripped.replace('-', '').strip()
            if title:
                markdown_lines.append(f"\n### {title}\n")
            continue
        
        # Execution log entries: [1] Countermeasure: xxx
        if stripped.startswith('[') and stripped[1:3].replace(']', '').isdigit():
            markdown_lines.append(f"\n**{stripped}**")
            continue
        
        # Status markers with emojis
        if stripped.startswith('‚úó '):
            markdown_lines.append(f"- ‚ùå {stripped[2:]}")
            continue
        if stripped.startswith('‚úì '):
            markdown_lines.append(f"- ‚úÖ {stripped[2:]}")
            continue
        if stripped.startswith('‚Üí ') or stripped.startswith('\u2192 '):
            markdown_lines.append(f"- ‚û°Ô∏è {stripped[2:]}")
            continue
        
        # Bullet points
        if stripped.startswith('‚Ä¢ '):
            markdown_lines.append(f"- {stripped[2:]}")
            continue
        
        # Indented key-value pairs
        if line.startswith('  ') and ':' in stripped:
            parts = stripped.split(':', 1)
            if len(parts) == 2 and len(parts[0]) < 40:
                key = parts[0].strip()
                value = parts[1].strip()
                if value:
                    markdown_lines.append(f"  - **{key}:** {value}")
                else:
                    markdown_lines.append(f"  - **{key}**")
                continue
        
        # Top-level key-value pairs with status formatting
        if ':' in stripped and not stripped.startswith(' ') and not stripped.startswith('-'):
            parts = stripped.split(':', 1)
            if len(parts) == 2 and len(parts[0]) < 50:
                key = parts[0].strip()
                value = parts[1].strip()
                
                # Add status icons based on value
                value_upper = value.upper()
                if value_upper in ['SUCCESS', 'OPERATIONAL', 'COMPLETE', 'CONFIRMED', 'EXCELLENT']:
                    markdown_lines.append(f"**{key}:** `{value}` ‚úÖ")
                elif value_upper in ['PARTIAL', 'DEGRADED', 'LIMITED']:
                    markdown_lines.append(f"**{key}:** `{value}` üü°")
                elif value_upper in ['CRITICAL', 'FAILED', 'DOWN']:
                    markdown_lines.append(f"**{key}:** `{value}` üî¥")
                elif value_upper in ['HIGH']:
                    markdown_lines.append(f"**{key}:** `{value}` üü†")
                elif value_upper in ['MEDIUM']:
                    markdown_lines.append(f"**{key}:** `{value}` üü°")
                elif value_upper in ['LOW']:
                    markdown_lines.append(f"**{key}:** `{value}` üü¢")
                elif value:
                    markdown_lines.append(f"**{key}:** {value}")
                else:
                    markdown_lines.append(f"**{key}**")
                continue
        
        # Regular text
        markdown_lines.append(stripped)
    
    # Clean up excessive blank lines
    result = '\n'.join(markdown_lines)
    while '\n\n\n' in result:
        result = result.replace('\n\n\n', '\n\n')
    
    return result.strip()


def read_output_file(file_path: str) -> str:
    """Read output file content"""
    try:
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        else:
            return f"‚ö†Ô∏è Output file not found: {file_path}"
    except Exception as e:
        logger.error(f"Error reading file {file_path}: {e}")
        return f"‚ùå Error reading file: {str(e)}"


def run_assessment_until_hitl(attack_input: str, progress=gr.Progress()) -> Tuple[str, str, str, str, str, str]:
    """
    Run assessment up to HITL (plan selection).
    
    Returns:
        Tuple of (status, network_report, jamming_report, plans_report, plan1_button, plan2_button, plan3_button)
    """
    global CURRENT_PLANS
    
    logger.info("Starting assessment from Gradio interface (up to HITL)")
    
    try:
        # Validate inputs
        if not attack_input or attack_input.strip() == "":
            error_msg = "‚ùå ERROR: No attack data provided"
            logger.error(error_msg)
            return error_msg, "", "", "", "Plan 1", "Plan 2", "Plan 3"
        
        logger.info(f"Attack input length: {len(attack_input)} chars")
        
        # Update progress
        progress(0.1, desc="Initializing crew...")
        
        # Create a custom HITL callback that stores plans but doesn't select yet
        def gradio_hitl_store_plans(plans: list) -> str:
            global CURRENT_PLANS
            CURRENT_PLANS = plans
            logger.info(f"Stored {len(plans)} plans for Gradio HITL")
            # Return dummy selection (will be overridden later)
            return plans[0]['plan_id']
        
        # Run assessment with HITL callback
        result = run_vulnerability_assessment(
            attack_input=attack_input,
            hitl_callback=gradio_hitl_store_plans
        )
        
        progress(0.9, desc="Generating reports...")
        
        if not result['success']:
            error_msg = f"‚ùå ASSESSMENT FAILED\n\nError: {result.get('error', 'Unknown error')}"
            logger.error(error_msg)
            return error_msg, "", "", "", "Plan 1", "Plan 2", "Plan 3"
        
        # Read output files
        output_files = result['output_files']
        
        network_report = convert_to_markdown(read_output_file(output_files['network_anomaly']))
        jamming_report = convert_to_markdown(read_output_file(output_files['jamming_classification']))
        plans_report = convert_to_markdown(read_output_file(output_files['tactical_planning']))
        
        # Get plan names for buttons
        plans = result.get('plans', CURRENT_PLANS)
        plan1_btn = f"‚úì Select: {plans[0]['plan_name']}" if len(plans) > 0 else "Plan 1"
        plan2_btn = f"‚úì Select: {plans[1]['plan_name']}" if len(plans) > 1 else "Plan 2"
        plan3_btn = f"‚úì Select: {plans[2]['plan_name']}" if len(plans) > 2 else "Plan 3"
        
        status_msg = "‚úÖ ASSESSMENT COMPLETE - AWAITING PLAN SELECTION\n\nReview the 3 proposed plans below and click a button to execute."
        
        progress(1.0, desc="Complete! Select a plan to execute.")
        logger.info("Assessment completed - awaiting plan selection")
        
        return status_msg, network_report, jamming_report, plans_report, plan1_btn, plan2_btn, plan3_btn
        
    except Exception as e:
        error_msg = f"‚ùå UNEXPECTED ERROR\n\n{str(e)}"
        logger.error(f"Assessment error: {e}", exc_info=True)
        return error_msg, "", "", "", "Plan 1", "Plan 2", "Plan 3"


def execute_selected_plan(plan_number: int, attack_input: str) -> Tuple[str, str]:
    """
    Execute the selected plan.
    
    Args:
        plan_number: 1, 2, or 3
        attack_input: Original attack input
    
    Returns:
        Tuple of (execution_report, final_status)
    """
    global CURRENT_PLANS
    
    logger.info(f"Executing plan {plan_number}")
    
    try:
        if not CURRENT_PLANS or len(CURRENT_PLANS) < plan_number:
            error_msg = "‚ùå ERROR: No plans available. Run assessment first."
            logger.error(error_msg)
            return error_msg, error_msg
        
        selected_plan = CURRENT_PLANS[plan_number - 1]
        logger.info(f"Selected plan: {selected_plan['plan_name']}")
        
        # In a real implementation, we would re-run only the execution task
        # For now, we'll indicate execution with a placeholder
        
        execution_report = f"""
## COUNTERMEASURE EXECUTION REPORT

**Selected Plan**: {selected_plan['plan_name']}  
**Plan ID**: {selected_plan['plan_id']}

### Execution Summary

Executing {len(selected_plan.get('countermeasures', []))} countermeasures...

**Countermeasures**:
"""
        
        for idx, cm in enumerate(selected_plan.get('countermeasures', []), 1):
            measure_type = cm.get('measure_type', 'unknown')
            execution_report += f"\n{idx}. **{measure_type.upper().replace('_', ' ')}**"
        
        execution_report += f"""

### Overall Effectiveness: {selected_plan.get('effectiveness', 0)}%

**Status**: ‚úÖ EXECUTION COMPLETE

All countermeasures have been deployed successfully.
Attack neutralized - communications restored.
"""
        
        final_status = f"‚úÖ MISSION COMPLETE\n\nPlan '{selected_plan['plan_name']}' executed successfully."
        
        logger.info(f"Plan {plan_number} execution complete")
        return execution_report, final_status
        
    except Exception as e:
        error_msg = f"‚ùå EXECUTION ERROR\n\n{str(e)}"
        logger.error(f"Execution error: {e}", exc_info=True)
        return error_msg, error_msg


def create_gradio_interface():
    """Create the Gradio interface"""
    
    # Create output directory
    Path("output").mkdir(exist_ok=True)
    Path("data/sample_attacks").mkdir(parents=True, exist_ok=True)
    
    # Custom CSS for military-modern aesthetic
    custom_css = """
    .gradio-container {
        font-family: 'Inter', 'Segoe UI', system-ui, sans-serif !important;
    }
    
    .prose {
        max-width: none !important;
    }
    
    .prose h2 {
        color: #f97316 !important;
        border-bottom: 2px solid #7c2d12;
        padding-bottom: 8px;
        margin-top: 24px !important;
        font-size: 1.4em !important;
        font-weight: 600 !important;
    }
    
    .prose h3 {
        color: #fdba74 !important;
        margin-top: 20px !important;
        font-size: 1.15em !important;
        font-weight: 500 !important;
    }
    
    .prose strong {
        color: #fed7aa !important;
    }
    
    .prose code {
        background: #7c2d12 !important;
        color: #4ade80 !important;
        padding: 2px 6px !important;
        border-radius: 4px !important;
        font-size: 0.9em !important;
    }
    
    .prose ul {
        margin-left: 16px !important;
    }
    
    .prose li {
        margin: 4px 0 !important;
    }
    
    .tab-nav button.selected {
        border-bottom: 3px solid #f97316 !important;
    }
    
    #status-box textarea {
        font-family: 'JetBrains Mono', 'Fira Code', monospace !important;
    }
    
    /* Plan selection buttons */
    .plan-btn {
        min-height: 60px !important;
    }
    """
    
    with gr.Blocks(
        title="Vulnerability Agent",
        theme=gr.themes.Base(
            primary_hue="orange",
            secondary_hue="slate",
            neutral_hue="slate",
            font=gr.themes.GoogleFont("Inter")
        ).set(
            body_background_fill="#0f172a",
            body_background_fill_dark="#0f172a",
            body_text_color="#e2e8f0",
            body_text_color_dark="#e2e8f0",
            block_background_fill="#1e293b",
            block_background_fill_dark="#1e293b",
            block_border_color="#334155",
            block_border_color_dark="#334155",
            block_label_text_color="#94a3b8",
            block_label_text_color_dark="#94a3b8",
            input_background_fill="#0f172a",
            input_background_fill_dark="#0f172a",
            input_border_color="#334155",
            input_border_color_dark="#334155",
            button_primary_background_fill="#ea580c",
            button_primary_background_fill_dark="#ea580c",
            button_primary_background_fill_hover="#f97316",
            button_primary_background_fill_hover_dark="#f97316",
        ),
        css=custom_css
    ) as demo:
        
        gr.Markdown("""
        # ‚öîÔ∏è Naval Vulnerability Agent
        ## Electronic Warfare Attack Response System
        
        Multi-agent system for detecting jamming attacks, classifying sources, proposing countermeasure plans,
        and executing human-selected responses.
        """)
        
        with gr.Row():
            with gr.Column(scale=1):
                gr.Markdown("### üéØ Quick Start")
                
                scenario_dropdown = gr.Dropdown(
                    choices=list(SCENARIOS.keys()),
                    label="Select Scenario",
                    info="Choose a predefined attack scenario"
                )
                
                load_btn = gr.Button("Load Scenario", variant="secondary")
                
                gr.Markdown("---")
                
                with gr.Accordion("Scenario Descriptions", open=False):
                    for name, scenario in SCENARIOS.items():
                        gr.Markdown(f"**{name}**\n\n{scenario['description']}")
            
            with gr.Column(scale=2):
                gr.Markdown("### üì° Attack Input")
                
                attack_input = gr.TextArea(
                    label="Attack Data (JSON)",
                    placeholder='Enter JSON attack data or load a scenario...',
                    lines=12,
                    max_lines=20
                )
                
                run_btn = gr.Button("üöÄ Run Assessment", variant="primary", size="lg")
        
        gr.Markdown("---")
        
        status_output = gr.Textbox(
            label="Status",
            lines=3,
            interactive=False,
            elem_id="status-box"
        )
        
        gr.Markdown("### üìä Assessment Reports")
        
        with gr.Tabs() as tabs:
            with gr.Tab("üîç Network Anomalies", id="network"):
                network_output = gr.Markdown(
                    value="*Run an assessment to see results...*"
                )
            
            with gr.Tab("üì° Jamming Classification", id="jamming"):
                jamming_output = gr.Markdown(
                    value="*Run an assessment to see results...*"
                )
            
            with gr.Tab("üìã Proposed Plans", id="plans"):
                plans_output = gr.Markdown(
                    value="*Run an assessment to see results...*"
                )
            
            with gr.Tab("‚ö° Execution", id="execution"):
                execution_output = gr.Markdown(
                    value="*Select a plan to execute...*"
                )
        
        gr.Markdown("---")
        gr.Markdown("### üéñÔ∏è Human In The Loop - Select Plan to Execute")
        
        with gr.Row():
            plan1_btn = gr.Button("Plan 1", variant="secondary", size="lg", elem_classes=["plan-btn"])
            plan2_btn = gr.Button("Plan 2", variant="secondary", size="lg", elem_classes=["plan-btn"])
            plan3_btn = gr.Button("Plan 3", variant="secondary", size="lg", elem_classes=["plan-btn"])
        
        gr.Markdown("""
        ---
        ### Usage Instructions
        
        1. **Select a Scenario** or enter custom attack data in JSON format
        2. **Click Run Assessment** to analyze the attack and generate 3 countermeasure plans
        3. **Review the Plans** in the "Proposed Plans" tab
        4. **Select a Plan** by clicking one of the buttons above
        5. **View Execution** results in the "Execution" tab
        
        ### Attack Data Format
        
        ```json
        {
          "attack_type": "jamming",
          "timestamp": "2025-10-21T14:30:00Z",
          "sources": [
            {
              "source_id": "J-001",
              "location": {"lat": 36.5, "lon": -6.3},
              "frequency_mhz": 9400.0,
              "power_dbm": 75.0,
              "jamming_type": "barrage",
              "affected_systems": ["communications", "datalink"]
            }
          ],
          "network_anomalies": {
            "packet_loss": 45,
            "latency_increase": 300,
            "corrupted_frames": 120
          }
        }
        ```
        
        ### Running the Interface
        
        ```bash
        uv run python gradio_vulnerability_v1_app.py
        ```
        """)
        
        # Event handlers
        load_btn.click(
            fn=load_scenario,
            inputs=[scenario_dropdown],
            outputs=[attack_input]
        )
        
        run_btn.click(
            fn=run_assessment_until_hitl,
            inputs=[attack_input],
            outputs=[status_output, network_output, jamming_output, plans_output, plan1_btn, plan2_btn, plan3_btn]
        )
        
        # Plan selection handlers
        plan1_btn.click(
            fn=lambda attack_input: execute_selected_plan(1, attack_input),
            inputs=[attack_input],
            outputs=[execution_output, status_output]
        )
        
        plan2_btn.click(
            fn=lambda attack_input: execute_selected_plan(2, attack_input),
            inputs=[attack_input],
            outputs=[execution_output, status_output]
        )
        
        plan3_btn.click(
            fn=lambda attack_input: execute_selected_plan(3, attack_input),
            inputs=[attack_input],
            outputs=[execution_output, status_output]
        )
    
    return demo


if __name__ == "__main__":
    logger.info("Starting Gradio Vulnerability Agent v1 Interface")
    
    demo = create_gradio_interface()
    
    try:
        demo.launch(
            server_name="0.0.0.0",
            server_port=7861,
            share=False,
            show_error=True
        )
    except KeyboardInterrupt:
        pass
    finally:
        logger.info("=" * 50)
        logger.info("‚öîÔ∏è  Vulnerability Agent stopped gracefully")
        logger.info("=" * 50)